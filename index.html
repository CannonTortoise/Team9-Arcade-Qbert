<!DOCTYPE html>
<html>
<head>
    <script src="phaser.js"></script>
</head>
<body>

<script>
// Map
var mapStartPos;
var mapSize;
var mapData; //2d array. 0 no cube; 1 color1; 2 color2
var cubes;
var cubeLength;
var cubeSprites;

// Player
var player;
var playerData;
var moveCurve;
var graphics;
var isMovingPreviousFrame;

// Red ball
var redBall;
var redBallData;
var RBmoveCurve;
var RBisMovingPreviousFrame;
var RBisActive;

// Bomb
var bombs;
var bombsMaxNum;
var bomb_offset_y;
var explosions;
var bombRemoveTime;

var locx;
var locy;
var cubex;
var cubey;

// Initialize the soap
var soap;
var soapx;
var soapy;
var soapCubex;
var soapCubey;
var SisActive;
var explosionUpgrade;

// Keys
var leftKey;
var rightKey;
var upKey;
var downKey;
var operateKey; //place a bomb, continue, restart ...
var cheatKey;

// UI
var winText;
var loseText;
var scoreText;
var bombsUI;

// Level
var currentLevel = 1; //1level1 2level2 3level3
var levelConfig = new Array();
levelConfig[0] = {cubeTypeNum: 2, isChangePermanent: true};
levelConfig[1] = {cubeTypeNum: 3, isChangePermanent: true};
levelConfig[2] = {cubeTypeNum: 3, isChangePermanent: false};
var cubeTypeNum;
var isChangePermanent;

// Score
var score = 0;
var scoreBase = 50;

// Game & Scene
var gameScene = {
    key: 'game',
    init: init,
    preload: preload,
    create: create,
    update: update
};

var menuScene = {
    key: 'menu',
    preload: menuPreload,
    create: menuCreate,
    update: menuUpdate
};

var config = {
    type: Phaser.AUTO,
    width: 700,
    height: 700,
    scene: [menuScene, gameScene]
};

var gameState; //0 start 1 win 2 lose
var game = new Phaser.Game(config);

// Duck image animation in menu
var duckImages = new Array();
var duckMaxRotation = 0.5;
var duckDirsDefault = new Array(1,-1,1,-1);
var duckDirsCurrent = new Array(1,-1,1,-1);
var duckRotateSpeed = 0.02;

function menuPreload()
{
    this.load.image('background', 'assets/images/background.png');
    this.load.image('backgroundBubble', 'assets/images/background-bubble.png');
    this.load.image('instruction', 'assets/images/Instruction.png');
    this.load.image('title', 'assets/images/Title.png');
    this.load.spritesheet('startButton','assets/images/Start button.png', { frameWidth: 139, frameHeight: 57 });
    this.load.spritesheet('duck_left', 'assets/images/duck1.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_down', 'assets/images/duck2.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_right', 'assets/images/duck3.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_up', 'assets/images/duck4.png', { frameWidth: 64, frameHeight: 64 });
}

function menuCreate()
{
    this.add.image(0, 0, 'background').setOrigin(0);
    this.add.image(0, 0, 'backgroundBubble').setOrigin(0);
    this.add.image(350, 220, 'title').setOrigin(0.5);
    this.add.image(350, 435, 'instruction').setOrigin(0.5);

    var duckDistance = 80;
    var duckY = 345;
    duckImages[0] = this.add.image(350 - 1.5 * duckDistance, duckY, 'duck_left').setOrigin(0.5);
    duckImages[1] = this.add.image(350 - 0.5 * duckDistance, duckY, 'duck_down').setOrigin(0.5);
    duckImages[2] = this.add.image(350 + 0.5 * duckDistance, duckY, 'duck_up').setOrigin(0.5);
    duckImages[3] = this.add.image(350 + 1.5 * duckDistance, duckY, 'duck_right').setOrigin(0.5);

    var startButton = this.add.sprite(350, 545, 'startButton').setOrigin(0.5);
    startButton.setInteractive();
    startButton.on('pointerdown', () => { this.scene.start('game'); });
    startButton.on('pointerover', () => { startButton.setTexture('startButton', 1); });
    startButton.on('pointerout', () => { startButton.setTexture('startButton', 0); });
}

function menuUpdate(){
    for (var i=0; i<duckImages.length; i++){
        duckImages[i].rotation += duckDirsCurrent[i] * duckRotateSpeed;
        if(duckDirsDefault[i]==1)
            if(duckImages[i].rotation <= 0 || duckImages[i].rotation >= duckMaxRotation)
                duckDirsCurrent[i] = -duckDirsCurrent[i];
        if(duckDirsDefault[i]==-1)
            if(duckImages[i].rotation >= 0 || duckImages[i].rotation <= -duckMaxRotation)
                duckDirsCurrent[i] = -duckDirsCurrent[i];
    }
}

function init()
{
    // Init level
    cubeTypeNum = levelConfig[currentLevel-1].cubeTypeNum;
    isChangePermanent = levelConfig[currentLevel-1].isChangePermanent;
    cubeSprites = new Array('cube1','cube2','cube3');

    // Init map
    mapStartPos = {pos_x: 350, pos_y: 130};

    mapSize = 7;
    explosionUpgrade = false;

    mapData  = new Array(mapSize); //2d array. 0 no cube; 1 color1; 2 color2
    for(var i = 0; i < mapSize; i++){
        mapData[i] = new Array(mapSize);
        for(var j = 0; j < mapSize; j++){
           if(i+j<mapSize)
               mapData[i][j] = 1;
           else
               mapData[i][j] = 0;
        }
    }

    cubeLength = {x: 43, y: 75}

    // Init player
    playerData = {
      x: 0,
      y: 0,
      ini_pos_x: 350,
      ini_pos_y: 85,
      scale: 1,
      followSpeed: 600
    };

    isMovingPreviousFrame = false;
    SisActive = false;

    // Init bomb
    bomb_offset_y = 0;
    bombsMaxNum = 5;
    bombRemoveTime = 3000;

    // Init redBall
    redBallData = {
      x: 0,
      y: 0,
      ini_pos_x: 350,
      ini_pos_y: 90,
      scale: 0.7,
      bornTime: 5000,
      respawnTime: 5000,
      followSpeed: 1000
    };

    RBisMovingPreviousFrame = true;
    RBisActive = false;

    // Init gameState
    gameState = 0;
}

function preload ()
{
    // Load resources
    this.load.image('cube1', 'assets/images/cube1.png');
    this.load.image('cube2', 'assets/images/cube2.png');
    this.load.image('cube3', 'assets/images/cube3.png');
    this.load.image('soap_bar','assets/images/soap_bar.png');
    this.load.spritesheet('bubble','assets/images/bubble.png', { frameWidth: 50, frameHeight: 50 });
    this.load.image('bomb_explosion','assets/images/bubble_boom.png');
    this.load.spritesheet('duck_left', 'assets/images/duck1.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_down', 'assets/images/duck2.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_right', 'assets/images/duck3.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_up', 'assets/images/duck4.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('mud_ball', 'assets/images/mud_ball.png', { frameWidth: 120, frameHeight: 80 });
}

function create ()
{
    // Draw cubes
    cubes = new Array(mapSize);
    for(var i = 0; i < mapSize; i++)
       cubes[i] = new Array(mapSize);
    for(var i = 0; i < mapSize; i++){
       for(var j = 0; j < mapSize; j++){
          if(mapData[i][j] == 1)
            cubes[i][j] = this.add.image(mapStartPos.pos_x + cubeLength.x * (j - i), mapStartPos.pos_y + cubeLength.y * (i + j), cubeSprites[0]);
       }
    }

    // Draw player
    player = this.add.follower(moveCurve, playerData.ini_pos_x, playerData.ini_pos_y, 'duck_left');

    player.scale = playerData.scale;
    graphics = this.add.graphics();
    graphics.lineStyle(1, 0xffffff, 1);

    // Add animation
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('duck_left', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('duck_right', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'up',
        frames: this.anims.generateFrameNumbers('duck_up', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'down',
        frames: this.anims.generateFrameNumbers('duck_down', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });


    // Draw red ball
    redBall = this.add.follower(RBmoveCurve, redBallData.ini_pos_x, redBallData.ini_pos_y, 'mud_ball');
    redBall.alpha = 0;
    redBall.scale = redBallData.scale;
    setTimeout(ActivateRedBall, redBallData.bornTime)

    this.anims.create({
        key: 'mud_jump',
        frames: this.anims.generateFrameNumbers('mud_ball', { start: 0, end: 11 }),
        frameRate: 15,
        repeat: 0
    });

    // Add keyboard keys
    leftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT);
    rightKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
    upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
    downKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
    operateKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    cheatKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    //set up soap class
    var Soap = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Soap (scene, x, y)
        {
            Phaser.GameObjects.Image.call(this, scene)
            this.setTexture('soap_bar');
            this.setPosition(-80, 0);
            this.setOrigin(0);
            scene.children.add(this);
        }
    });
    soap = new Soap(this, 3, 4);

    //set up bomb class
    var Bomb = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Bomb (scene)
        {
            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bubble');
        },

        create: function (x, y, cx, cy)
        {
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);

            this.setActive(true);
            this.setVisible(true);
        },

        burstTimeout: function(time)
        {
            setTimeout(this.remove.bind(this), time);
        },

        burst: function()
        {
            setTimeout(this.remove.bind(this), 100);
        },

        remove:function()
        {
            var explosion = explosions.get();
            if(explosion)
                explosion.create(this.x, this.y, this.cubex, this.cubey, 500);
            this.setActive(false);
            this.setVisible(false);
        }
    });

    bombs = this.add.group({
        classType: Bomb,
        maxSize: bombsMaxNum
    });

    this.anims.create({
        key: 'bubble_burst',
        frames: this.anims.generateFrameNumbers('bubble', { start: 0, end: 4 }),
        frameRate: 10,
        repeat: 0
    });

    //set up explosion class
    var Explosion = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Explosion (scene)
        {
            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bomb_explosion');
        },

        create: function (x, y, cx, cy, time)
        {
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);

            this.setActive(true);
            this.setVisible(true);
            setTimeout(this.remove.bind(this), time);

            // Destroy red ball if it is closed to explosion
            var explosionCenter = this.getCenter();
            var distance = explosionCenter.distance(redBall.getCenter())
            if(distance < 50)
                ResetBall();
        },

        remove: function()
        {
            changeCubeColor(this.cubex, this.cubey);
            if(explosionUpgrade == true)
            {
                changeCubeColor(this.cubex - 1, this.cubey);
                changeCubeColor(this.cubex, this.cubey - 1);
                changeCubeColor(this.cubex + 1, this.cubey - 1);
                changeCubeColor(this.cubex + 1, this.cubey);
                changeCubeColor(this.cubex, this.cubey + 1);
                changeCubeColor(this.cubex - 1, this.cubey + 1);
            }
            explosionUpgrade = false;
            this.setActive(false);
            this.setVisible(false);
        }
    });

    explosions = this.add.group({
        classType: Explosion,
        maxSize: bombsMaxNum
    });

    // Init win&lose UI
    winText = this.add.text(350, 300, 'Level '+ currentLevel + ' Complete!\nPress Space to Continue.');
    winText.setOrigin(0.5, 0.5);
    winText.setStyle({
        fontSize: '36px',
        color: '#FF0000',
    });
    winText.alpha = 0;

    loseText = this.add.text(350, 300, 'Game Over!\nPress Space to Restart.');
    loseText.setOrigin(0.5, 0.5);
    loseText.setStyle({
        fontSize: '36px',
        color: '#FF0000',
    });
    loseText.alpha = 0;

    // Init score
    scoreText = this.add.text(10, 30, 'Score: '+ score);

    // Level UI
    this.add.text(10, 10, 'Level: ' + currentLevel);

    // Init bombs UI
    bombsUI = this.add.group({key:'bubble', frame:0, repeat:bombsMaxNum-1, setXY:{x:20, y:65, stepX:24}, setScale:{x: 0.4}});

    addSoap();
    //setTimeout(addSoap, 8000);

    // Init target
    this.add.text(690, 10, 'Change To').setOrigin(1,0);
    this.add.image(672, 35, cubeSprites[cubeTypeNum-1]).setOrigin(1,0).setScale(0.5);
}

function update ()
{

    if(Phaser.Input.Keyboard.JustDown(cheatKey)){
        gameState = 1;
        winText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }

    // next level
    if(gameState == 1 && Phaser.Input.Keyboard.JustDown(operateKey))
        NextLevel(this.scene);

    // restart
    if(gameState == 2 && Phaser.Input.Keyboard.JustDown(operateKey)){
        currentLevel = 1;
        score = 0;
        this.scene.restart();
    }

    if(gameState != 0)
        return;

    // create bomb
    if (Phaser.Input.Keyboard.JustDown(operateKey) && !player.isFollowing())
    {
        if(bombs.countActive() < bombsMaxNum)
            CreateBomb();
    }
    // player move
    PlayerMove();
    // red ball move
    if(RBisActive){
        RBMove();
        LoseCondition();
    }

    if(playerData.x == soapCubex && playerData.y == soapCubey)
    {
      explosionUpgrade = true;
      removeSoap();
    }
    // Update UI
    UpdateScore();
    UpdateBombsUI();
}

function addSoap(){
    setRandPos();
    soap.setPosition(soapx, soapy);
    SisActive = true;
}

function removeSoap(){
  soap.setPosition(-80, 0);
  SisActive = false;
  var wait = 0;
  addSoap();
}

function UpdateScore(){
    scoreText.setText('Score: '+ score);
}

function UpdateBombsUI(){
    var remainNum = bombsMaxNum - bombs.countActive();
    var bui = bombsUI.getChildren();
    var i = 0;
    for(; i<remainNum; i++)
        bui[i].visible = true;
    for(; i<bombsMaxNum; i++)
        bui[i].visible = false;
}

function CreateBomb(){
    var bomb = bombs.get();
    if(bomb){
        bomb.create(player.x, player.y + bomb_offset_y, playerData.x, playerData.y);
        bomb.burstTimeout(bombRemoveTime);
    }
}


function removeAllBombs(time){
    var children = bombs.getChildren();
    for(var i=0; i<children.length; i++)
        if(children[i].active)
            children[i].burstTimeout(time);
}

function ActivateRedBall(){
    RBisActive = true;
    redBall.alpha = 1;
    redBallData.x = 0;
    redBallData.y = 0;
    redBall.x = redBallData.ini_pos_x;
    redBall.y = redBallData.ini_pos_y;
    UpdateRBMovingCurve(0, 0);
    RBisMovingPreviousFrame = true;
}

function ResetBall(){
    redBall.alpha = 0;
    RBisActive = false;
    setTimeout(ActivateRedBall, redBallData.respawnTime);
}

function RedBallMovement(){
      var ballDirection = Math.floor((Math.random() * 2));
      if(redBallData.x + redBallData.y >= mapSize)
          ResetBall();
      else{
          if(ballDirection == 0){
              UpdateRBMovingCurve(-cubeLength.x,cubeLength.y);
              redBallData.x += 1;
          }
          else{
              UpdateRBMovingCurve(cubeLength.x,cubeLength.y);
              redBallData.y += 1;
          }
      }
      redBall.anims.play('mud_jump', true);
}

function RBMove(){
    if(RBisMovingPreviousFrame && !redBall.isFollowing())
        RBArrival();
    RBisMovingPreviousFrame = redBall.isFollowing();
}

function PlayerMove(){
    if(isMovingPreviousFrame && !player.isFollowing())
        PlayerArrival();
    isMovingPreviousFrame = player.isFollowing();
    // If moving, input is invalid.
    if(player.isFollowing()){
        return;
    }

    // Movement
    if (Phaser.Input.Keyboard.JustDown(leftKey))
    {
        UpdateMovingCurve(-cubeLength.x,cubeLength.y);
        playerData.x += 1;
        player.anims.play('left', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(rightKey))
    {
        UpdateMovingCurve(cubeLength.x,-cubeLength.y);
        playerData.x -= 1;
        player.anims.play('right', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(upKey))
    {
        UpdateMovingCurve(-cubeLength.x,-cubeLength.y);
        playerData.y -= 1;
        player.anims.play('up', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(downKey))
    {
        UpdateMovingCurve(cubeLength.x,cubeLength.y);
        playerData.y += 1;
        player.anims.play('down', true);
    }
}

function UpdateMovingCurve(_x,_y){
    //Initialize moving curve
    var points = [];
    points.push(new Phaser.Math.Vector2(player.x, player.y));

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        points.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    //bounce
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y - Math.abs(_y*0.2)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y + Math.abs(_y*0.1)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    moveCurve = new Phaser.Curves.Spline(points);
    //moveCurve.draw(graphics, 128);

    //Set follower's path and speed
    player.setPath(moveCurve);
    player.startFollow(playerData.followSpeed);
}

function UpdateRBMovingCurve(_x,_y){
    //Initialize moving curve
    var rbpoints = [];

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        rbpoints.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    RBmoveCurve = new Phaser.Curves.Spline(rbpoints);

    //Set follower's path and speed
    redBall.setPath(RBmoveCurve);
    redBall.startFollow(redBallData.followSpeed);
}

function RBArrival(){
    reverseCubeColor(redBallData.x, redBallData.y);
    setTimeout(RedBallMovement, 100);
}

function PlayerArrival(){
    //Judge Lose
    LoseCondition();
}

function reverseCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;
    //Change cube color
    if(mapData[x][y] >= 2){
        mapData[x][y] -= 1;
        cubes[x][y].setTexture(cubeSprites[mapData[x][y]-1]);
    }
}

function changeCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;

    //Change cube color
    if(mapData[x][y] > 0 && mapData[x][y] < cubeTypeNum){
        mapData[x][y] += 1;
        cubes[x][y].setTexture(cubeSprites[mapData[x][y]-1]);
        score += scoreBase;
    }
    else if(mapData[x][y] == cubeTypeNum && !isChangePermanent){
        mapData[x][y] = 1;
        cubes[x][y].setTexture(cubeSprites[0]);
        score += scoreBase;
    }
    //Judge Win
    WinCondition();
}

function setRandPos(){
    var randCube = Math.floor((Math.random() * 28) + 1);
    if(randCube == 1){soapx = 300; soapy = 65; soapCubex = 0; soapCubey = 0;}
    else if(randCube == 2){soapx = 257; soapy = 140; soapCubex = 1; soapCubey = 0;}
    else if(randCube == 3){soapx = 343; soapy = 140; soapCubex = 0; soapCubey = 1;}
    else if(randCube == 4){soapx = 214; soapy = 215; soapCubex = 2; soapCubey = 0;}
    else if(randCube == 5){soapx = 300; soapy = 215; soapCubex = 1; soapCubey = 1;}
    else if(randCube == 6){soapx = 386; soapy = 215; soapCubex = 0; soapCubey = 2;}
    else if(randCube == 7){soapx = 171; soapy = 290; soapCubex = 3; soapCubey = 0;}
    else if(randCube == 8){soapx = 257; soapy = 290; soapCubex = 2; soapCubey = 1;}
    else if(randCube == 9){soapx = 343; soapy = 290; soapCubex = 1; soapCubey = 2;}
    else if(randCube == 10){soapx = 429; soapy = 290; soapCubex = 0; soapCubey = 3;}
    else if(randCube == 11){soapx = 128; soapy = 365; soapCubex = 4; soapCubey = 0;}
    else if(randCube == 12){soapx = 214; soapy = 365; soapCubex = 3; soapCubey = 1;}
    else if(randCube == 13){soapx = 300; soapy = 365; soapCubex = 2; soapCubey = 2;}
    else if(randCube == 14){soapx = 386; soapy = 365; soapCubex = 1; soapCubey = 3;}
    else if(randCube == 15){soapx = 472; soapy = 365; soapCubex = 0; soapCubey = 4;}
    else if(randCube == 16){soapx = 85; soapy = 440; soapCubex = 5; soapCubey = 0;}
    else if(randCube == 17){soapx = 171; soapy = 440; soapCubex = 4; soapCubey = 1;}
    else if(randCube == 18){soapx = 257; soapy = 440; soapCubex = 3; soapCubey = 2;}
    else if(randCube == 19){soapx = 343; soapy = 440; soapCubex = 2; soapCubey = 3;}
    else if(randCube == 20){soapx = 429; soapy = 440; soapCubex = 1; soapCubey = 4;}
    else if(randCube == 21){soapx = 515; soapy = 440; soapCubex = 0; soapCubey = 5;}
    else if(randCube == 22){soapx = 42; soapy = 515; soapCubex = 6; soapCubey = 0;}
    else if(randCube == 23){soapx = 128; soapy = 515; soapCubex = 5; soapCubey = 1;}
    else if(randCube == 24){soapx = 214; soapy = 515; soapCubex = 4; soapCubey = 2;}
    else if(randCube == 25){soapx = 300; soapy = 515; soapCubex = 3; soapCubey = 3;}
    else if(randCube == 26){soapx = 386; soapy = 515; soapCubex = 2; soapCubey = 4;}
    else if(randCube == 27){soapx = 472; soapy = 515; soapCubex = 1; soapCubey = 5;}
    else if(randCube == 28){soapx = 558; soapy = 515; soapCubex = 0; soapCubey = 6;}
    soapx += 10;
    soapy -= 5;
}

function WinCondition(){
    var isWinner = true;
    for(var i = 0; i < mapSize; i++){
        for(var j = 0; j < mapSize; j++){
            if(mapData[i][j] > 0 && mapData[i][j] < cubeTypeNum){
                isWinner = false;
                break;
            }
        }
        if(isWinner == false)
            break;
    }

    if(isWinner){
        gameState = 1;
        winText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }

    return isWinner;
}

function LoseCondition(){
    var isLoser = false;
    //Player out of bounds
    if(playerData.x<0 || playerData.y<0 || playerData.x + playerData.y >= mapSize)
        isLoser = true;
    //distance between player and redball
    if(RBisActive){
        var playerCenter = player.getCenter();
        var distance = playerCenter.distance(redBall.getCenter())
        if(distance < 20)
            isLoser = true;
    }

    if(isLoser){
        gameState = 2;
        loseText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }
    return isLoser;
}

function NextLevel(scene){
    if(currentLevel == 3){
        currentLevel = 1;
        scene.start('menu');
    }
    else{
        currentLevel++;
        scene.restart();
    }
}

</script>

</body>
</html>
