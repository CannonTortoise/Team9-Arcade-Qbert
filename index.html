<!DOCTYPE html>
<html>
<head>
    <script src="phaser.js"></script>
</head>
<body>

<style media='screen' type='text/css'>
      @font-face {
        font-family: font1;
        src: url('assets/fonts/munro.ttf');
        font-weight:400;
        font-weight:normal;
      }
</style>
    
<div style="font-family:font1; position:absolute; left:-1000px; visibility:hidden;">.</div>
    
<script>
// Map
var mapStartPos;
var mapSize;
var mapData; //2d array. 0 no cube; 1 color1; 2 color2
var cubes;
var cubeLength;
var cubeSprites;

// Player
var player;
var playerData;
var moveCurve;
var graphics;
var isMovingPreviousFrame;

// Red ball
var redBall;
var redBallData;
var RBmoveCurve;
var RBisMovingPreviousFrame;
var RBisActive;
var RBresetCount = 0;
var RBlatestReset;
var RBExplosion;
var RBexplosionRemoveTime;

// Bomb
var bombs;
var bombsMaxNum;
var bomb_offset_y;
var explosions;
var bombRemoveTime;
var explosionRemoveTime;

var locx;
var locy;
var cubex;
var cubey;
    
var superBubble;
var superBubbleScale;

// Initialize the soap
var soap;
var soapx;
var soapy;
var soapCubex;
var soapCubey;
var soapIntervalTime;
var SisActive;
var explosionUpgrade;

// Keys
var leftKey;
var rightKey;
var upKey;
var downKey;
var operateKey; //place a bomb, continue, restart ...
var cheatKey;

// UI
var winText;
var loseText;
var loseAnim;
var scoreText;
var bombsUI;

// Level
var currentLevel = 1; //1level1 2level2 3level3
var levelConfig = new Array();
levelConfig[0] = {cubeTypeNum: 2, isChangePermanent: true};
levelConfig[1] = {cubeTypeNum: 3, isChangePermanent: true};
levelConfig[2] = {cubeTypeNum: 3, isChangePermanent: false};
var cubeTypeNum;
var isChangePermanent;
var levelIcon;    


// Score
var score = 0;
var scoreBase = 50;

// Game & Scene
var gameScene = {
    key: 'game',
    init: init,
    preload: preload,
    create: create,
    update: update
};

var menuScene = {
    key: 'menu',
    preload: menuPreload,
    create: menuCreate,
    update: menuUpdate
};

var config = {
    type: Phaser.AUTO,
    width: 1280,
    height: 700,
    scene: [menuScene, gameScene],
    autoCenter: true
};

var gameState; //0 start 1 win 2 lose
var game = new Phaser.Game(config);

// Duck image animation in menu
var duckImages = new Array();
var duckMaxRotation = 0.5;
var duckDirsDefault = new Array(1,-1,1,-1);
var duckDirsCurrent = new Array(1,-1,1,-1);
var duckRotateSpeed = 0.02;

// Sounds
var music;
var sound_bubble_pop;
var sound_ding;
var sound_squeak;
var sound_super_bubble_pop;
    
function menuPreload()
{
    this.load.image('bg', 'assets/images/cabinet_art.png');
    this.load.image('background', 'assets/images/background.png');
    this.load.image('backgroundBubble', 'assets/images/background-bubble.png');
    this.load.image('instruction', 'assets/images/Instruction.png');
    this.load.image('title', 'assets/images/Title.png');
    this.load.spritesheet('startButton','assets/images/Start button.png', { frameWidth: 139, frameHeight: 57 });
    this.load.spritesheet('duck_left', 'assets/images/duck1.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_down', 'assets/images/duck2.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_right', 'assets/images/duck3.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_up', 'assets/images/duck4.png', { frameWidth: 64, frameHeight: 64 });
}

function menuCreate()
{
    this.add.image(0, 0, 'bg').setOrigin(0);
    this.add.image(config.width/2, config.height/2, 'background').setOrigin(0.5);
    this.add.image(config.width/2, config.height/2, 'backgroundBubble').setOrigin(0.5);
    this.add.image(config.width/2, 220, 'title').setOrigin(0.5);
    this.add.image(config.width/2, 435, 'instruction').setOrigin(0.5);

    var duckDistance = 80;
    var duckY = 345;
    duckImages[0] = this.add.image(config.width/2 - 1.5 * duckDistance, duckY, 'duck_left').setOrigin(0.5);
    duckImages[1] = this.add.image(config.width/2 - 0.5 * duckDistance, duckY, 'duck_down').setOrigin(0.5);
    duckImages[2] = this.add.image(config.width/2 + 0.5 * duckDistance, duckY, 'duck_up').setOrigin(0.5);
    duckImages[3] = this.add.image(config.width/2 + 1.5 * duckDistance, duckY, 'duck_right').setOrigin(0.5);

    var startButton = this.add.sprite(config.width/2, 545, 'startButton').setOrigin(0.5);
    startButton.setInteractive();
    startButton.on('pointerdown', () => { this.scene.start('game'); });
    startButton.on('pointerover', () => { startButton.setTexture('startButton', 1); });
    startButton.on('pointerout', () => { startButton.setTexture('startButton', 0); });
}

function menuUpdate(){
    for (var i=0; i<duckImages.length; i++){
        duckImages[i].rotation += duckDirsCurrent[i] * duckRotateSpeed;
        if(duckDirsDefault[i]==1)
            if(duckImages[i].rotation <= 0 || duckImages[i].rotation >= duckMaxRotation)
                duckDirsCurrent[i] = -duckDirsCurrent[i];
        if(duckDirsDefault[i]==-1)
            if(duckImages[i].rotation >= 0 || duckImages[i].rotation <= -duckMaxRotation)
                duckDirsCurrent[i] = -duckDirsCurrent[i];
    }
}

function init()
{
    // Init level
    cubeTypeNum = levelConfig[currentLevel-1].cubeTypeNum;
    isChangePermanent = levelConfig[currentLevel-1].isChangePermanent;
    if(currentLevel==1)
        cubeSprites = new Array('cube2','cube1');
    else if(currentLevel==2)
        cubeSprites = new Array('cube5','cube4','cube1');
    else if(currentLevel==3)
        cubeSprites = new Array('cube5','cube4','cube1');

    // Init map
    mapStartPos = {pos_x: config.width/2, pos_y: 130};

    mapSize = 7;
    explosionUpgrade = false;

    mapData  = new Array(mapSize); //2d array. 0 no cube; 1 color1; 2 color2
    for(var i = 0; i < mapSize; i++){
        mapData[i] = new Array(mapSize);
        for(var j = 0; j < mapSize; j++){
           if(i+j<mapSize)
               mapData[i][j] = 1;
           else
               mapData[i][j] = 0;
        }
    }

    cubeLength = {x: 43, y: 75}

    // Init player
    playerData = {
      x: 0,
      y: 0,
      ini_pos_x: config.width/2,
      ini_pos_y: 85,
      scale: 1,
      followSpeed: 600
    };

    isMovingPreviousFrame = false;
    SisActive = false;

    // Init bomb
    bomb_offset_y = 0;
    bombsMaxNum = 5;
    bombRemoveTime = 3000;
    explosionRemoveTime = 600;
    superBubbleScale = 3;

    // Init redBall
    redBallData = {
      x: 0,
      y: 0,
      ini_pos_x: config.width/2,
      ini_pos_y: 85,
      scale: 0.7,
      bornTime: 7000,
      respawnTime: 10000,
      followSpeed: 1000
    };

    RBisMovingPreviousFrame = true;
    RBisActive = false;
    RBexplosionRemoveTime = 400;
    
    soapIntervalTime = 10000;

    // Init gameState
    gameState = 0;
}

function preload ()
{
    // Load resources
    this.load.image('cube1', 'assets/images/clenaing_cube.png');
    this.load.image('cube2', 'assets/images/mud_cube.png');
    this.load.image('cube3', 'assets/images/puddle_cube.png');
    this.load.image('cube4', 'assets/images/suds_cube.png');
    this.load.image('cube5', 'assets/images/soapscum_cube.png');
    this.load.image('soap_bar','assets/images/soap_bar.png');
    this.load.spritesheet('bubble','assets/images/bubble.png', { frameWidth: 50, frameHeight: 50 });
    this.load.image('bomb_explosion','assets/images/bubble_boom.png');
    this.load.spritesheet('duck_left', 'assets/images/duck1.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_down', 'assets/images/duck2.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_right', 'assets/images/duck3.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_up', 'assets/images/duck4.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('mud_ball', 'assets/images/mud_ball.png', { frameWidth: 120, frameHeight: 80 });
    this.load.image('mud_ball_explosion', 'assets/images/when_mud_ball_meet_bubble_ball.png');
    this.load.image('background', 'assets/images/background.png');
    this.load.image('backgroundBubble', 'assets/images/background-bubble.png');
    this.load.image('bg', 'assets/images/cabinet_art.png');
    
    // Audio
    this.load.audio('bubble_pop', 'assets/audio/bubble_pop.ogg');
    this.load.audio('ding', 'assets/audio/elevator_ding.ogg');
    this.load.audio('music', 'assets/audio/soap_freeze_music.ogg');
    this.load.audio('squeak', 'assets/audio/squeak_sound.ogg');
    this.load.audio('super_bubble_pop', 'assets/audio/super_bubble_pop.ogg');
    
    // Level&Gameover
    this.load.image('level1_0', 'assets/images/Lvl_1_Frame1.png');
    this.load.image('level1_1', 'assets/images/Lvl_1_Frame2.png');
    //this.load.image('level1_2', 'assets/images/Lvl_1_Frame3.png');
    this.load.image('level2_0', 'assets/images/Lvl_2_Frame1.png');
    this.load.image('level2_1', 'assets/images/Lvl_2_Frame2.png');
    this.load.image('level2_2', 'assets/images/Lvl_2_Frame3.png');
    this.load.image('level3_0', 'assets/images/Lvl_3_Frame1.png');
    this.load.image('level3_1', 'assets/images/Lvl_3_Frame2.png');
    this.load.image('level3_2', 'assets/images/Lvl_3_Frame3.png');
    this.load.image('gameOver_0', 'assets/images/GameOver_Frame1.png');
    this.load.image('gameOver_1', 'assets/images/GameOver_Frame2.png');
    this.load.image('gameOver_2', 'assets/images/GameOver_Frame3.png');
}

function create ()
{
    // background
    this.add.image(0, 0, 'bg').setOrigin(0);
    this.add.image(config.width/2, config.height/2, 'background').setOrigin(0.5);
    this.add.image(config.width/2, config.height/2, 'backgroundBubble').setOrigin(0.5);

    // Draw cubes
    cubes = new Array(mapSize);
    for(var i = 0; i < mapSize; i++)
       cubes[i] = new Array(mapSize);
    for(var i = 0; i < mapSize; i++){
       for(var j = 0; j < mapSize; j++){
          if(mapData[i][j] == 1)
            cubes[i][j] = this.add.image(mapStartPos.pos_x + cubeLength.x * (j - i), mapStartPos.pos_y + cubeLength.y * (i + j), cubeSprites[0]);
       }
    }

    // Draw player
    player = this.add.follower(moveCurve, playerData.ini_pos_x, playerData.ini_pos_y, 'duck_left');

    player.scale = playerData.scale;
    graphics = this.add.graphics();
    graphics.lineStyle(1, 0xffffff, 1);

    // Add animation
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('duck_left', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('duck_right', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'up',
        frames: this.anims.generateFrameNumbers('duck_up', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'down',
        frames: this.anims.generateFrameNumbers('duck_down', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });


    // Draw red ball
    redBall = this.add.follower(RBmoveCurve, redBallData.ini_pos_x, redBallData.ini_pos_y, 'mud_ball',7);
    redBall.alpha = 0;
    redBall.scale = redBallData.scale;
    RBresetCount++;
    RBlatestReset = RBresetCount;
    setTimeout(ActivateRedBall, redBallData.bornTime, RBresetCount);

    this.anims.create({
        key: 'mud_jump',
        frames: this.anims.generateFrameNumbers('mud_ball', { frames:[7,8,9,10,11,0,1,2,3,4,5,6,7] }),
        frameRate: 12,
        repeat: 0
    });

    class RedBallExplosion extends Phaser.GameObjects.Sprite {
        constructor(config) {
            super(config.scene, config.x, config.y, "mud_ball_explosion");
            config.scene.add.existing(this);
            this.remove();
        }

        create(x,y,time){
            this.setActive(true).setVisible(true);
            this.setPosition(x, y);
            setTimeout(this.remove.bind(this), time);
        }

        remove()
        {
          	this.setActive(false).setVisible(false);
        }
    }
    RBExplosion = new RedBallExplosion({scene:this, x:50, y:50});

    // Add keyboard keys
    leftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT);
    rightKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
    upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
    downKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
    operateKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    cheatKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    //set up soap class
    var Soap = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Soap (scene, x, y)
        {
            Phaser.GameObjects.Image.call(this, scene)
            this.setTexture('soap_bar');
            this.setPosition(-80, 0);
            this.setOrigin(0);
            scene.children.add(this);
        }
    });
    soap = new Soap(this, 3, 4);

    //set up bomb class
    var Bomb = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Bomb (scene)
        {
            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bubble');
            this.count = 0;
        },

        create: function (x, y, cx, cy)
        {
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);
            this.able = true;

            this.setActive(true);
            this.setVisible(true);
            this.count+=1;
            setTimeout(this.burst.bind(this,this.count), bombRemoveTime);
        },

        // when colliding with red ball
        disable: function()
        {
            this.able = false;
            this.setActive(false);
            this.setVisible(false);
        },

        burst: function(count)
        {
            if(!this.able)
                return;
            if(count!=this.count)
                return;

            var explosion = explosions.get();
            if(explosion)
                explosion.create(this.x, this.y, this.cubex, this.cubey, explosionRemoveTime);
            this.setActive(false);
            this.setVisible(false);
        }
    });

    bombs = this.add.group({
        classType: Bomb,
        maxSize: bombsMaxNum
    });

    this.anims.create({
        key: 'bubble_burst',
        frames: this.anims.generateFrameNumbers('bubble', { start: 0, end: 5 }),
        frameRate: 15,
        repeat: 0
    });

    //set up explosion class
    var Explosion = new Phaser.Class({
        Extends: Phaser.GameObjects.Sprite,
        initialize:
        function Explosion (scene)
        {
            Phaser.GameObjects.Sprite.call(this, scene, 0, 0, 'bubble');
        },

        create: function (x, y, cx, cy, time)
        {
            sound_bubble_pop.play();
            this.play('bubble_burst');
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);
            this.able = true;

            this.setActive(true);
            this.setVisible(true);
            setTimeout(this.remove.bind(this), time);

            // Destroy red ball if it is closed to explosion
            //var explosionCenter = this.getCenter();
            //var distance = explosionCenter.distance(redBall.getCenter())
            //if(distance < 50)
                //ResetBall();
        },

        remove: function()
        {
            if(!this.able)
                return;

            changeCubeColor(this.cubex, this.cubey);
            if(explosionUpgrade == true)
            {
                changeCubeColor(this.cubex - 1, this.cubey);
                changeCubeColor(this.cubex, this.cubey - 1);
                changeCubeColor(this.cubex + 1, this.cubey - 1);
                changeCubeColor(this.cubex + 1, this.cubey);
                changeCubeColor(this.cubex, this.cubey + 1);
                changeCubeColor(this.cubex - 1, this.cubey + 1);
            }
            explosionUpgrade = false;
            this.setActive(false);
            this.setVisible(false);
        },

        disable: function()
        {
            this.able = false;
            this.setActive(false);
            this.setVisible(false);
            explosionUpgrade = false;
        }
    });

    explosions = this.add.group({
        classType: Explosion,
        maxSize: bombsMaxNum
    });

    // superbubble
    class SuperBubble extends Phaser.GameObjects.Sprite {
        constructor(config) {
            super(config.scene, config.x, config.y, "bubble");
            config.scene.add.existing(this);
            this.setOrigin(0.5, 0.5);
            this.setScale(superBubbleScale);
            this.setActive(false).setVisible(false);
        }

        create(px,py,branch,time){
            this.able = true;
            this.setActive(true).setVisible(true); 
            
            this.play('bubble_burst');
            sound_super_bubble_pop.play();
            setTimeout(this.remove.bind(this), time);
            
            // Position
            var superBubbleX = mapStartPos.pos_x + cubeLength.x * (py - px);
            var superBubbleY = mapStartPos.pos_y + cubeLength.y * (px + py);
            var x_offset = cubeLength.x;
            var y_offset = cubeLength.y/2;
            var extra_y_offset = -30;
            switch(branch) {
                case 1:
                    //l&lup
                    superBubbleX -= x_offset;
                    superBubbleY -= y_offset;
                    break;
                case 2:
                    //lup&rup
                    superBubbleY -= y_offset + extra_y_offset;
                    break;
                case 3:
                    //rup&r
                    superBubbleX += x_offset;
                    superBubbleY -= y_offset;
                    break;
                case 4:
                    //r&rdown
                    superBubbleX += x_offset;
                    superBubbleY += y_offset + extra_y_offset;
                    break;
                case 5:
                    //rdown&ldown
                    superBubbleY += y_offset;
                    break;
                case 6:
                    //ldown&l
                    superBubbleX -= x_offset;
                    superBubbleY += y_offset + extra_y_offset;
                    break;

            } 
            this.setPosition(superBubbleX, superBubbleY);
            this.px = px;
            this.py = py;
            this.branch = branch
        }

        remove()
        {
            if(this.able){
                this.setActive(false).setVisible(false);
                var px = this.px, py = this.py;
                switch(this.branch) {
                    case 1:
                        //l&lup
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px+1,py-1);changeCubeColor(px+1,py-1);
                        changeCubeColor(px,py-1);changeCubeColor(px,py-1);
                        break;
                    case 2:
                        //lup&rup
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px,py-1);changeCubeColor(px,py-1);
                        changeCubeColor(px-1,py);changeCubeColor(px-1,py);
                        break;
                    case 3:
                        //rup&r
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px-1,py);changeCubeColor(px-1,py);
                        changeCubeColor(px-1,py+1);changeCubeColor(px-1,py+1);
                        break;
                    case 4:
                        //r&rdown
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px-1,py+1);changeCubeColor(px-1,py+1);
                        changeCubeColor(px,py+1);changeCubeColor(px,py+1);
                        break;
                    case 5:
                        //rdown&ldown
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px,py+1);changeCubeColor(px,py+1);
                        changeCubeColor(px+1,py);changeCubeColor(px+1,py);
                        break;
                    case 6:
                        //ldown&l
                        changeCubeColor(px,py);changeCubeColor(px,py);
                        changeCubeColor(px+1,py);changeCubeColor(px+1,py);
                        changeCubeColor(px+1,py-1);changeCubeColor(px+1,py-1);
                        break;
                }
            }
        }

        disable()
        {
            this.able = false;
            this.setActive(false).setVisible(false);
        }
    }
    superBubble = new SuperBubble({scene:this, x:100, y:100});
    
    // Init win&lose UI
    winText = this.add.text(config.width/2, 350, 'Level Complete! Press Space to Continue.').setOrigin(0.5, 0.5);
    winText.setStyle({
        fontFamily: 'font1',
        fontSize: '32px',
        color: '#000000',
    });
    winText.alpha = 0;

    loseText = this.add.text(config.width/2, 450, 'Press Space to Restart.').setOrigin(0.5, 0.5);
    loseText.setStyle({
        fontFamily: 'font1',
        fontSize: '32px',
        color: '#000000',
    });
    loseText.alpha = 0;
    
    this.anims.create({
        key: 'gameover',
        frames: [
            { key: 'gameOver_0' },
            { key: 'gameOver_1' },
            { key: 'gameOver_2' },
        ],
        frameRate: 8,
        repeat: 0
    });
    loseAnim = this.add.sprite(config.width/2, 350, 'gameOver_0').setOrigin(0.5).play('gameover');
    loseAnim.setVisible(false);

    // Init score
    scoreText = this.add.text(300, 30, 'Score:  '+ score, {fontFamily: 'font1', color: '#000000'});

    // Level UI
    this.add.text(300, 10, 'Level:  ' + currentLevel, {fontFamily: 'font1', color: '#000000'});

    // Init bombs UI
    bombsUI = this.add.group({key:'bubble', frame:0, repeat:bombsMaxNum-1, setXY:{x:310, y:65, stepX:24}, setScale:{x: 0.4}});

    addSoap();
    //setTimeout(addSoap, 8000);

    // Init target
    this.add.text(958, 10, 'Target', {fontFamily: 'font1', color: '#000000'}).setOrigin(1,0);
    this.add.image(965, 35, cubeSprites[cubeTypeNum-1]).setOrigin(1,0).setScale(0.6);
    
    // Init music&sounds
    if(music == null){
        music = this.sound.add('music');
        music.loop = true;
        music.play();
    }
    
    sound_bubble_pop = this.sound.add('bubble_pop');
    sound_ding = this.sound.add('ding');
    sound_ding.play();
    sound_squeak = this.sound.add('squeak');
    sound_super_bubble_pop = this.sound.add('super_bubble_pop');
    
    // Level icon
    this.anims.create({
        key: 'level'+currentLevel,
        frames: [
            { key: 'level'+ currentLevel + '_0' },
            { key: 'level'+ currentLevel + '_1' },
            { key: 'level'+ currentLevel + '_0' },
            { key: 'level'+ currentLevel + '_1' }
        ],
        frameRate: 8,
        repeat: 0
    });
    
    levelIcon = this.add.sprite(config.width/2, 350, 'level'+ currentLevel + '_0').setOrigin(0.5).play('level'+currentLevel);
    setTimeout(closeLevelIcon,1500);
}

function closeLevelIcon(){
    levelIcon.setActive(false).setVisible(false);
}    
    
function update ()
{

    if(Phaser.Input.Keyboard.JustDown(cheatKey)){
        gameState = 1;
        winText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }

    // next level
    if(gameState == 1 && Phaser.Input.Keyboard.JustDown(operateKey))
        NextLevel(this.scene);

    // restart
    if(gameState == 2 && Phaser.Input.Keyboard.JustDown(operateKey)){
        currentLevel = 1;
        score = 0;
        this.scene.restart();
        ResetBall();
        var bombsChildren = bombs.getChildren();
        for(var i=0; i<bombsChildren.length; i++)
            if(bombsChildren[i].active)
                bombsChildren[i].disable();
        var explosionsChildren = explosions.getChildren();
        for(var i=0; i<explosionsChildren.length; i++)
            if(explosionsChildren[i].active)
                explosionsChildren[i].disable();
        superBubble.disable();
    }

    if(gameState != 0)
        return;

    // create bomb
    if (Phaser.Input.Keyboard.JustDown(operateKey) && !player.isFollowing())
    {
        if(bombs.countActive() < bombsMaxNum)
            CreateBomb();
    }
    // player move
    PlayerMove();
    // red ball move
    if(RBisActive){
        CheckRedballCollision();
        RBMove();
        LoseCondition();
    }

    if(soap.getCenter().distance(player.getCenter())<30)
    {
        explosionUpgrade = true;
        removeSoap();
    }
    // Update UI
    UpdateScore();
    UpdateBombsUI();
}

function addSoap(){
    setRandPos();
    soap.setPosition(soapx, soapy);
    SisActive = true;
}

function removeSoap(){
  soap.setPosition(-80, 0);
  SisActive = false;
  setTimeout(addSoap,soapIntervalTime);
}

function UpdateScore(){
    scoreText.setText('Score:  '+ score);
}

function UpdateBombsUI(){
    var remainNum = bombsMaxNum - bombs.countActive();
    var bui = bombsUI.getChildren();
    var i = 0;
    for(; i<remainNum; i++)
        bui[i].visible = true;
    for(; i<bombsMaxNum; i++)
        bui[i].visible = false;
}

function CreateBomb(){
    var bomb = bombs.get();
    if(bomb)
        bomb.create(player.x, player.y + bomb_offset_y, playerData.x, playerData.y);
    

    //super bubble
    var px = playerData.x, py = playerData.y;
    var bombsChildren = bombs.getChildren();
    var lup = -1,rup = -1,l = -1,r = -1,ldown = -1,rdown = -1;//record index
    for(var i=0; i<bombsChildren.length; i++){
        if(bombsChildren[i].active){
            if(bombsChildren[i].cubex == px && bombsChildren[i].cubey == py-1)
                lup = i;
            else if(bombsChildren[i].cubex == px-1 && bombsChildren[i].cubey == py)
                rup = i;
            else if(bombsChildren[i].cubex == px+1 && bombsChildren[i].cubey == py-1)
                l = i;
            else if(bombsChildren[i].cubex == px-1 && bombsChildren[i].cubey == py+1)
                r = i;
            else if(bombsChildren[i].cubex == px+1 && bombsChildren[i].cubey == py)
                ldown = i;
            else if(bombsChildren[i].cubex == px && bombsChildren[i].cubey == py+1)
                rdown = i;
        }
    }
    if(l!=-1 && lup!=-1){
        bomb.disable();
        bombsChildren[l].disable();
        bombsChildren[lup].disable();
        superBubble.create(px,py,1,explosionRemoveTime);
    }
    else if(lup!=-1 && rup!=-1){
        bomb.disable();
        bombsChildren[lup].disable();
        bombsChildren[rup].disable();
        superBubble.create(px,py,2,explosionRemoveTime);
    }
    else if(rup!=-1 && r!=-1){
        bomb.disable();
        bombsChildren[rup].disable();
        bombsChildren[r].disable();
        superBubble.create(px,py,3,explosionRemoveTime);
    }
    else if(r!=-1 && rdown!=-1){
        bomb.disable();
        bombsChildren[r].disable();
        bombsChildren[rdown].disable();
        superBubble.create(px,py,4,explosionRemoveTime);
    }
    else if(rdown!=-1 && ldown!=-1){
        bomb.disable();
        bombsChildren[rdown].disable();
        bombsChildren[ldown].disable();
        superBubble.create(px,py,5,explosionRemoveTime);
    }
    else if(ldown!=-1 && l!=-1){
        bomb.disable();
        bombsChildren[ldown].disable();
        bombsChildren[l].disable();
        superBubble.create(px,py,6,explosionRemoveTime);
    }
}
    

function removeAllBombs(time){
    var children = bombs.getChildren();
    for(var i=0; i<children.length; i++)
        if(children[i].active)
            children[i].burstTimeout(time);
}

function ActivateRedBall(resetCount){
    if(resetCount!=RBlatestReset)
        return;
    RBisActive = true;
    redBall.alpha = 1;
    redBallData.x = 0;
    redBallData.y = 0;
    redBall.x = redBallData.ini_pos_x;
    redBall.y = redBallData.ini_pos_y;
    UpdateRBMovingCurve(0, 0);
    RBisMovingPreviousFrame = true;
}

function ResetBall(){
    RBresetCount++;
    RBlatestReset = RBresetCount;
    redBall.alpha = 0;
    RBisActive = false;
    setTimeout(ActivateRedBall, redBallData.respawnTime, RBresetCount);
}

function RedBallMovement(){
      var ballDirection = Math.floor((Math.random() * 2));
      if(redBallData.x + redBallData.y >= mapSize)
          ResetBall();
      else{
          if(ballDirection == 0){
              UpdateRBMovingCurve(-cubeLength.x,cubeLength.y);
              redBallData.x += 1;
          }
          else{
              UpdateRBMovingCurve(cubeLength.x,cubeLength.y);
              redBallData.y += 1;
          }
      }
      redBall.anims.play('mud_jump', true);
}

function RBMove(){
    if(RBisMovingPreviousFrame && !redBall.isFollowing())
        RBArrival();
    RBisMovingPreviousFrame = redBall.isFollowing();
}

function PlayerMove(){
    if(isMovingPreviousFrame && !player.isFollowing())
        PlayerArrival();
    isMovingPreviousFrame = player.isFollowing();
    // If moving, input is invalid.
    if(player.isFollowing()){
        return;
    }

    // Movement
    if (Phaser.Input.Keyboard.JustDown(leftKey))
    {
        sound_squeak.play();
        UpdateMovingCurve(-cubeLength.x,cubeLength.y);
        playerData.x += 1;
        player.anims.play('left', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(rightKey))
    {
        sound_squeak.play();
        UpdateMovingCurve(cubeLength.x,-cubeLength.y);
        playerData.x -= 1;
        player.anims.play('right', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(upKey))
    {
        sound_squeak.play();
        UpdateMovingCurve(-cubeLength.x,-cubeLength.y);
        playerData.y -= 1;
        player.anims.play('up', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(downKey))
    {
        sound_squeak.play();
        UpdateMovingCurve(cubeLength.x,cubeLength.y);
        playerData.y += 1;
        player.anims.play('down', true);
    }
}

function UpdateMovingCurve(_x,_y){
    //Initialize moving curve
    var points = [];
    points.push(new Phaser.Math.Vector2(player.x, player.y));

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        points.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    //bounce
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y - Math.abs(_y*0.2)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y + Math.abs(_y*0.1)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    moveCurve = new Phaser.Curves.Spline(points);
    //moveCurve.draw(graphics, 128);

    //Set follower's path and speed
    player.setPath(moveCurve);
    player.startFollow(playerData.followSpeed);
}

function UpdateRBMovingCurve(_x,_y){
    //Initialize moving curve
    var rbpoints = [];

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        rbpoints.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    RBmoveCurve = new Phaser.Curves.Spline(rbpoints);

    //Set follower's path and speed
    redBall.setPath(RBmoveCurve);
    redBall.startFollow(redBallData.followSpeed);
}

function RBArrival(){
    reverseCubeColor(redBallData.x, redBallData.y);
    setTimeout(RedBallMovement, 100);
}

function PlayerArrival(){
    //Judge Lose
    LoseCondition();
}

function reverseCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;
    //Change cube color
    if(mapData[x][y] >= 2){
        mapData[x][y] -= 1;
        cubes[x][y].setTexture(cubeSprites[mapData[x][y]-1]);
    }
}

function changeCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;

    //Change cube color
    if(mapData[x][y] > 0 && mapData[x][y] < cubeTypeNum){
        mapData[x][y] += 1;
        cubes[x][y].setTexture(cubeSprites[mapData[x][y]-1]);
        score += scoreBase;
    }
    else if(mapData[x][y] == cubeTypeNum && !isChangePermanent){
        mapData[x][y] = 1;
        cubes[x][y].setTexture(cubeSprites[0]);
        score += scoreBase;
    }
    //Judge Win
    WinCondition();
}

function setRandPos(){
    var randCube = Math.floor((Math.random() * 28) + 1);
    if(randCube == 1){soapx = 300; soapy = 65; soapCubex = 0; soapCubey = 0;}
    else if(randCube == 2){soapx = 257; soapy = 140; soapCubex = 1; soapCubey = 0;}
    else if(randCube == 3){soapx = 343; soapy = 140; soapCubex = 0; soapCubey = 1;}
    else if(randCube == 4){soapx = 214; soapy = 215; soapCubex = 2; soapCubey = 0;}
    else if(randCube == 5){soapx = 300; soapy = 215; soapCubex = 1; soapCubey = 1;}
    else if(randCube == 6){soapx = 386; soapy = 215; soapCubex = 0; soapCubey = 2;}
    else if(randCube == 7){soapx = 171; soapy = 290; soapCubex = 3; soapCubey = 0;}
    else if(randCube == 8){soapx = 257; soapy = 290; soapCubex = 2; soapCubey = 1;}
    else if(randCube == 9){soapx = 343; soapy = 290; soapCubex = 1; soapCubey = 2;}
    else if(randCube == 10){soapx = 429; soapy = 290; soapCubex = 0; soapCubey = 3;}
    else if(randCube == 11){soapx = 128; soapy = 365; soapCubex = 4; soapCubey = 0;}
    else if(randCube == 12){soapx = 214; soapy = 365; soapCubex = 3; soapCubey = 1;}
    else if(randCube == 13){soapx = 300; soapy = 365; soapCubex = 2; soapCubey = 2;}
    else if(randCube == 14){soapx = 386; soapy = 365; soapCubex = 1; soapCubey = 3;}
    else if(randCube == 15){soapx = 472; soapy = 365; soapCubex = 0; soapCubey = 4;}
    else if(randCube == 16){soapx = 85; soapy = 440; soapCubex = 5; soapCubey = 0;}
    else if(randCube == 17){soapx = 171; soapy = 440; soapCubex = 4; soapCubey = 1;}
    else if(randCube == 18){soapx = 257; soapy = 440; soapCubex = 3; soapCubey = 2;}
    else if(randCube == 19){soapx = 343; soapy = 440; soapCubex = 2; soapCubey = 3;}
    else if(randCube == 20){soapx = 429; soapy = 440; soapCubex = 1; soapCubey = 4;}
    else if(randCube == 21){soapx = 515; soapy = 440; soapCubex = 0; soapCubey = 5;}
    else if(randCube == 22){soapx = 42; soapy = 515; soapCubex = 6; soapCubey = 0;}
    else if(randCube == 23){soapx = 128; soapy = 515; soapCubex = 5; soapCubey = 1;}
    else if(randCube == 24){soapx = 214; soapy = 515; soapCubex = 4; soapCubey = 2;}
    else if(randCube == 25){soapx = 300; soapy = 515; soapCubex = 3; soapCubey = 3;}
    else if(randCube == 26){soapx = 386; soapy = 515; soapCubex = 2; soapCubey = 4;}
    else if(randCube == 27){soapx = 472; soapy = 515; soapCubex = 1; soapCubey = 5;}
    else if(randCube == 28){soapx = 558; soapy = 515; soapCubex = 0; soapCubey = 6;}
    soapx += 300;
    soapy -= 5;
}

function WinCondition(){
    var isWinner = true;
    for(var i = 0; i < mapSize; i++){
        for(var j = 0; j < mapSize; j++){
            if(mapData[i][j] > 0 && mapData[i][j] < cubeTypeNum){
                isWinner = false;
                break;
            }
        }
        if(isWinner == false)
            break;
    }

    if(isWinner){
        gameState = 1;
        winText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }

    return isWinner;
}

function LoseCondition(){
    var isLoser = false;
    //Player out of bounds
    if(playerData.x<0 || playerData.y<0 || playerData.x + playerData.y >= mapSize)
        isLoser = true;
    //distance between player and redball
    if(RBisActive){
        var playerCenter = player.getCenter();
        var distance = playerCenter.distance(redBall.getCenter())
        if(distance < 20)
            isLoser = true;
    }

    if(isLoser){
        gameState = 2;
        loseText.alpha = 1;
        loseAnim.setVisible(true);
        loseAnim.play('gameover');
        player.stopFollow();
        redBall.stopFollow();
    }
    return isLoser;
}

function NextLevel(scene){
    if(currentLevel == 3){
        currentLevel = 1;
        scene.start('menu');
    }
    else{
        currentLevel++;
        scene.restart();
        ResetBall();
        var bombsChildren = bombs.getChildren();
        for(var i=0; i<bombsChildren.length; i++)
            if(bombsChildren[i].active)
                bombsChildren[i].disable();
        var explosionsChildren = explosions.getChildren();
        for(var i=0; i<explosionsChildren.length; i++)
            if(explosionsChildren[i].active)
                explosionsChildren[i].disable();
        superBubble.disable();
    }
}

function CheckRedballCollision(){
    var children = bombs.getChildren();
    for(var i=0; i<children.length; i++){
        if(children[i].active){
            var distance = children[i].getCenter().distance(redBall.getCenter());
            if(distance < 30){
                ResetBall();
                RBExplosion.create(redBall.x,redBall.y,RBexplosionRemoveTime);
                children[i].disable();
                break;
            }
        }
    }

}

</script>

</body>
</html>
