<!DOCTYPE html>
<html>
<head>
    <script src="phaser.js"></script>
</head>
<body>

<script>

var config = {
    type: Phaser.AUTO,
    width: 600,
    height: 800,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        init: init,
        preload: preload,
        create: create,
        update: update
    }
};

// Map
var mapStartPos;
var mapSize;
var mapData; //2d array. 0 no cube; 1 color1; 2 cube_1_colorchange
var cubes;
var cubeLength;

// Player
var player;
var playerPos;
var moveCurve;
var graphics;
var isMovingPreviousFrame;
var canPlayerChangeColor = false;

// Red ball
var redBall;
var redBallPos;
var RBmoveCurve;
var RBisMovingPreviousFrame;
var RBisActive;

// Bomb
var bombs;
var bombsMaxNum;
var bomb_offset_y;
var explosions;

var locx;
var locy;
var cubex;
var cubey;

// Keys
var leftKey;
var rightKey;
var upKey;
var downKey;
var restartKey;
var bombKey;
var changeColorKey;

// UI
var winText;
var loseText;

// Game
var gameState; //0 start 1 win 2 lose
var game = new Phaser.Game(config);

var frames;
var xlevel;

function init()
{
    // Init map
    mapStartPos = {pos_x: 300, pos_y: 100};

    mapSize = 7;

    mapData  = new Array(mapSize); //2d array. 0 no cube; 1 color1; 2 cube_1_colorchange
    for(var i = 0; i < mapSize; i++){
        mapData[i] = new Array(mapSize);
        for(var j = 0; j < mapSize; j++){
           if(i+j<mapSize)
               mapData[i][j] = 1;
           else
               mapData[i][j] = 0;
        }
    }

    cubeLength = {x: 43, y: 75}

    // Init player
    playerPos = {
      x: 0,
      y: 0,
      ini_pos_x: 300,
      ini_pos_y: 55,
      scale: 1
    };

    isMovingPreviousFrame = false;

    // Init bomb
    bomb_offset_y = 0;
    bombsMaxNum = 4;

    // Init redBall
    redBallPos = {
      x: 0,
      y: 0,
      ini_pos_x: 300,
      ini_pos_y: 60,
      scale: 0.7
    };

    RBisMovingPreviousFrame = false;
    RBisActive = false;

    // Init gameState
    gameState = 0;
}

function preload ()
{
    // Load resources
    this.load.image('cube_1', 'assets/images/cube_1.png');
    this.load.image('cube_1_colorchange', 'assets/images/cube_1_colorchange.png');
    this.load.image('bubble','assets/images/bubble.png');
    this.load.image('bomb_explosion','assets/images/bubble_boom.png');
    this.load.spritesheet('duck_left', 'assets/images/duck1.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_down', 'assets/images/duck2.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_right', 'assets/images/duck3.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('duck_up', 'assets/images/duck4.png', { frameWidth: 64, frameHeight: 64 });
    this.load.spritesheet('mud_ball', 'assets/images/mud_ball.png', { frameWidth: 120, frameHeight: 80 });
}

function create ()
{
    // Draw cubes
    cubes = new Array(mapSize);
    for(var i = 0; i < mapSize; i++)
       cubes[i] = new Array(mapSize);
    for(var i = 0; i < mapSize; i++){
       for(var j = 0; j < mapSize; j++){
          if(mapData[i][j] == 1)
            cubes[i][j] = this.add.image(mapStartPos.pos_x + cubeLength.x * (j - i), mapStartPos.pos_y + cubeLength.y * (i + j), 'cube_1');
       }
    }

    // Draw player
    player = this.add.follower(moveCurve, playerPos.ini_pos_x, playerPos.ini_pos_y, 'duck_left');

    player.scale = playerPos.scale;
    graphics = this.add.graphics();
    graphics.lineStyle(1, 0xffffff, 1);

    // Add animation
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('duck_left', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('duck_right', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'up',
        frames: this.anims.generateFrameNumbers('duck_up', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });
    this.anims.create({
        key: 'down',
        frames: this.anims.generateFrameNumbers('duck_down', { start: 0, end: 7 }),
        frameRate: 9,
        repeat: 0
    });


    // Draw red ball
    redBall = this.add.follower(RBmoveCurve, redBallPos.ini_pos_x, redBallPos.ini_pos_y, 'mud_ball');
    redBall.alpha = 0;
    redBall.scale = redBallPos.scale;
    setTimeout(ActivateRedBall, 5000)

    this.anims.create({
        key: 'mud_jump',
        frames: this.anims.generateFrameNumbers('mud_ball', { start: 0, end: 11 }),
        frameRate: 15,
        repeat: 0
    });

    // Add keyboard keys
    leftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT);
    rightKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
    upKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
    downKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
    restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
    bombKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    changeColorKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
    frames = 0;
    xlevel = 0;

    //set up bomb class
    var Bomb = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Bomb (scene)
        {
            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bubble');
        },

        create: function (x, y, cx, cy)
        {
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);

            this.setActive(true);
            this.setVisible(true);
        },

        removeTimeout: function(time)
        {
            setTimeout(this.remove.bind(this), time);
        },

        remove: function()
        {

            var explosion = explosions.get();
            if(explosion)
                explosion.create(this.x, this.y, this.cubex, this.cubey, 500);

            this.setActive(false);
            this.setVisible(false);
        }
    });

    bombs = this.add.group({
        classType: Bomb,
        maxSize: bombsMaxNum
    });

    //set up explosion class
    var Explosion = new Phaser.Class({
        Extends: Phaser.GameObjects.Image,
        initialize:
        function Explosion (scene)
        {
            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bomb_explosion');
        },

        create: function (x, y, cx, cy, time)
        {
            this.cubex = cx;
            this.cubey = cy;
            this.setPosition(x, y);

            this.setActive(true);
            this.setVisible(true);
            setTimeout(this.remove.bind(this), time);

            var explosionCenter = this.getCenter();
            var distance = explosionCenter.distance(redBall.getCenter())
            if(distance < 50)
                ResetBall();
        },

        remove: function()
        {
            changeCubeColor(this.cubex, this.cubey);
            this.setActive(false);
            this.setVisible(false);
        }
    });

    explosions = this.add.group({
        classType: Explosion,
        maxSize: bombsMaxNum
    });

    // Init win&lose UI
    winText = this.add.text(300, 300, 'You Win!');
    winText.setOrigin(0.5, 0.5);
    winText.setStyle({
        fontSize: '42px',
        color: '#000000',
        align: 'center',
    });
    winText.alpha = 0;

    loseText = this.add.text(300, 300, 'Game over!');
    loseText.setOrigin(0.5, 0.5);
    loseText.setStyle({
        fontSize: '42px',
        color: '#000000',
        align: 'center',
    });
    loseText.alpha = 0;

}

function update ()
{
    if(Phaser.Input.Keyboard.JustDown(restartKey))
        this.scene.restart();
    if(gameState != 0)
        return;

    if(Phaser.Input.Keyboard.JustDown(changeColorKey))
        canPlayerChangeColor = !canPlayerChangeColor;

    if (Phaser.Input.Keyboard.JustDown(bombKey) && !player.isFollowing())
    {
        if(bombs.countActive() == 0)
            CreateOneBomb();
        else
            removeAllBombs(500);

        /*
        locx = player.x - 30;
        locy = player.y - 30;
        cubex = playerPos.x;
        cubey = playerPos.y;
        bomb.setPosition(locx, locy);
        setTimeout(removeBomb, 1000);*/
    }
    PlayerMove();
    if(RBisActive){
        RedBallMovement();
        RBMove();
        LoseCondition();
    }

}

function CreateOneBomb(){
    var bomb = bombs.get();
    if(bomb){
        bomb.create(player.x, player.y + bomb_offset_y, playerPos.x, playerPos.y);
        if(bombs.countActive() == bombsMaxNum)
            removeAllBombs(1000);
    }
}


function removeAllBombs(time){
    var children = bombs.getChildren();
    for(var i=0; i<children.length; i++)
        if(children[i].active)
            children[i].removeTimeout(time);
}

/*
function removeBomb(){
    bomb.setPosition(-80, 0);
    explosion.setPosition(locx, locy);
    setTimeout(removeExplosion, 1000)
}
*/
/*
function removeExplosion(){
    explosion.setPosition(-80, 0);
    changeCubeColor(cubex, cubey);

    if(cubex == 0){
        changeCubeColor(cubex, cubey);
        changeCubeColor(cubex, cubey + 1);
        changeCubeColor(cubex + 1, cubey);
        changeCubeColor(cubex, cubey - 1);
        changeCubeColor(cubex + 1, cubey - 1);
    }
    changeCubeColor(cubex, cubey);
    changeCubeColor(cubex - 1, cubey);
    changeCubeColor(cubex, cubey + 1);
    changeCubeColor(cubex + 1, cubey);
    changeCubeColor(cubex, cubey - 1);
    changeCubeColor(cubex - 1, cubey + 1);
    changeCubeColor(cubex + 1, cubey - 1);

}
*/
function ActivateRedBall(){
    RBisActive = true;
    redBall.alpha = 1;
}

function ResetBall(){
    redBall.x = redBallPos.ini_pos_x;
    redBall.y = redBallPos.ini_pos_y;
    redBallPos.x = 0;
    redBallPos.y = 0;
    UpdateRBMovingCurve(0, 0);
    redBall.alpha = 0;
    RBisActive = false;
    setTimeout(ActivateRedBall, 3000)
}

function RedBallMovement(){
    if(!RBisActive)
        return;
    if(frames > 50)
    {
        var ballDirection = Math.floor((Math.random() * 2));
        if(redBallPos.x + redBallPos.y >= mapSize)
            ResetBall();
        else{
          if(ballDirection == 0){
              UpdateRBMovingCurve(-cubeLength.x,cubeLength.y);
              redBallPos.x += 1;
              frames = 0;
          }
          else{
            UpdateRBMovingCurve(cubeLength.x,cubeLength.y);
            redBallPos.y += 1;
            frames = 0;
          }
        }
        redBall.anims.play('mud_jump', true);

    }
    frames++;
}
function RBMove(){
  if(RBisMovingPreviousFrame && !redBall.isFollowing())
      RBArrival();
  RBisMovingPreviousFrame = redBall.isFollowing();
}

function PlayerMove(){
    if(isMovingPreviousFrame && !player.isFollowing())
        PlayerArrival();
    isMovingPreviousFrame = player.isFollowing();
    // If moving, input is invalid.
    if(player.isFollowing()){
        return;
    }

    // Movement
    if (Phaser.Input.Keyboard.JustDown(leftKey))
    {
        UpdateMovingCurve(-cubeLength.x,cubeLength.y);
        playerPos.x += 1;
        player.anims.play('left', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(rightKey))
    {
        UpdateMovingCurve(cubeLength.x,-cubeLength.y);
        playerPos.x -= 1;
        player.anims.play('right', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(upKey))
    {
        UpdateMovingCurve(-cubeLength.x,-cubeLength.y);
        playerPos.y -= 1;
        player.anims.play('up', true);
    }
    else if (Phaser.Input.Keyboard.JustDown(downKey))
    {
        UpdateMovingCurve(cubeLength.x,cubeLength.y);
        playerPos.y += 1;
        player.anims.play('down', true);
    }
}

function UpdateMovingCurve(_x,_y){
    //Initialize moving curve
    var points = [];
    points.push(new Phaser.Math.Vector2(player.x, player.y));

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        points.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    //bounce
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y - Math.abs(_y*0.2)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y + Math.abs(_y*0.1)));
    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    points.push(new Phaser.Math.Vector2(player.x+_x, player.y + _y));

    moveCurve = new Phaser.Curves.Spline(points);
    //moveCurve.draw(graphics, 128);

    //Set follower's path and speed
    player.setPath(moveCurve);
    player.startFollow(600);
}

function UpdateRBMovingCurve(_x,_y){
    //Initialize moving curve
    var rbpoints = [];

    //parabola  y=ax^2+bx
    var a = 0.15;
    var b = (_y - a*_x*_x) / _x;
    for(i=0; i<=1; i+=0.1){
        var delta_x = _x * i;
        var delta_y = a*delta_x*delta_x + b*delta_x;
        rbpoints.push(new Phaser.Math.Vector2(player.x + delta_x, player.y + delta_y));
    }

    RBmoveCurve = new Phaser.Curves.Spline(rbpoints);

    //Set follower's path and speed
    redBall.setPath(RBmoveCurve);
    redBall.startFollow(600);
}

function RBArrival(){
  reverseCubeColor(redBallPos.x, redBallPos.y);
}

function PlayerArrival(){
    //Judge Lose
    if(LoseCondition())
        return;
    //Change cube color
    if(canPlayerChangeColor)
        changeCubeColor(playerPos.x, playerPos.y);
    //Create bombs
    if(bombs.countActive() > 0 && bombs.countActive() < bombsMaxNum)
        CreateOneBomb();
}

function reverseCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;
    //Change cube color
    if(mapData[x][y] == 2){
        mapData[x][y] = 1;
        cubes[x][y].setTexture('cube_1');
    }
}

function changeCubeColor(x,y){
    //Out of bounds
    if(x<0 || y<0 || x+y>= mapSize)
        return;
    //Change cube color
    if(mapData[x][y] == 1){
        mapData[x][y] = 2;
        cubes[x][y].setTexture('cube_1_colorchange');
    }
    //Judge Win
    WinCondition();
}

function WinCondition(){
    var isWinner = true;
    for(var i = 0; i < mapSize; i++){
        for(var j = 0; j < mapSize; j++){
            if(mapData[i][j] == 1){
                isWinner = false;
                break;
            }
        }
        if(isWinner == false)
            break;
    }

    if(isWinner){
        gameState = 1;
        winText.alpha = 1;
    }

    return isWinner;
}

function LoseCondition(){
    var isLoser = false;
    //Player out of bounds
    if(playerPos.x<0 || playerPos.y<0 || playerPos.x+playerPos.y >= mapSize)
        isLoser = true;
    //distance between player and redball
    if(RBisActive){
        var playerCenter = player.getCenter();
        var distance = playerCenter.distance(redBall.getCenter())
        if(distance < 20)
            isLoser = true;
    }

    if(isLoser){
        gameState = 2;
        loseText.alpha = 1;
        player.stopFollow();
        redBall.stopFollow();
    }
    return isLoser;
}

</script>

</body>
</html>
